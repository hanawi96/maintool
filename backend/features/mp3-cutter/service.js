// features/mp3-cutter/service.js (Self-contained)
import path from 'path';
import fs from 'fs/promises';
import { MP3_CONFIG } from './constants.js';
import { MP3Utils } from './utils.js';

export class MP3Service {
  
  static async processUpload(file, audioInfo) {
    // Auto cleanup after 2 hours
    setTimeout(() => fs.unlink(file.path).catch(() => {}), 2 * 60 * 60 * 1000);
    
    return {
      file: {
        originalName: file.originalname,
        filename: file.filename,
        size: file.size,
        mimetype: file.mimetype
      },
      audio: {
        duration: audioInfo.duration,
        format: audioInfo.format,
        codec: audioInfo.codec,
        bitrate: audioInfo.bitrate,
        channels: audioInfo.channels
      },
      urls: {
        download: `/api/mp3-cutter/download/${file.filename}`,
        cut: `/api/mp3-cutter/cut`
      },
      uploadedAt: new Date().toISOString()
    };
  }

  static async cutAudio(file, audioInfo, cutParams) {
    const { startTime, endTime, fadeIn, fadeOut } = cutParams;
    
    // Generate output filename
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 6);
    const outputFilename = `cut_${timestamp}_${random}.mp3`;
    const outputPath = path.resolve(MP3_CONFIG.PATHS.PROCESSED, outputFilename);
    
    // üîß **ENSURE OUTPUT DIR**: ƒê·∫£m b·∫£o th∆∞ m·ª•c output t·ªìn t·∫°i v·ªõi absolute path
    const outputDir = path.resolve(MP3_CONFIG.PATHS.PROCESSED);
    await fs.mkdir(outputDir, { recursive: true });
    
    // Cut the audio
    await MP3Utils.cutAudio(file.path, outputPath, {
      startTime, endTime, fadeIn, fadeOut, format: 'mp3', quality: 'medium'
    });
    
    // Get output file stats
    const outputStats = await fs.stat(outputPath);
    
    // Auto cleanup after 24 hours
    setTimeout(() => fs.unlink(outputPath).catch(() => {}), 24 * 60 * 60 * 1000);

    
    return {
      input: {
        filename: file.filename,
        originalName: file.originalname,
        duration: audioInfo.duration
      },
      output: {
        filename: outputFilename,
        duration: endTime - startTime,
        size: outputStats.size
      },
      processing: { startTime, endTime, fadeIn, fadeOut },
      urls: {
        download: `/api/mp3-cutter/download/${outputFilename}`
      },
      processedAt: new Date().toISOString()
    };
  }

  /**
   * üÜï **CUT AUDIO BY FILE ID**: Cut audio file b·∫±ng fileId ƒë√£ upload tr∆∞·ªõc ƒë√≥
   */
  static async cutAudioByFileId(fileId, cutParams, sessionId = null) {
    const { 
      startTime, 
      endTime, 
      fadeIn, 
      fadeOut, 
      playbackRate = 1,
      outputFormat = 'mp3', // üÜï **OUTPUT FORMAT**: L·∫•y format t·ª´ cutParams
      quality = 'high', // üÜï **QUALITY**: L·∫•y quality t·ª´ cutParams
      isInverted = false // üÜï **INVERT MODE**: Add invert mode parameter
    } = cutParams;
    
    // üîç **FIND INPUT FILE**: T√¨m file ƒë√£ upload theo fileId v·ªõi absolute path
    const inputPath = path.resolve(MP3_CONFIG.PATHS.UPLOADS, fileId);
    
    try {
      // üîç **CHECK FILE EXISTS**: Ki·ªÉm tra file c√≥ t·ªìn t·∫°i
      await fs.access(inputPath);
    } catch (error) {
      console.error('‚ùå [cutAudioByFileId] Input file not found:', {
        fileId,
        inputPath,
        error: error.message
      });
      throw new Error(`File not found: ${fileId}. Please upload the file again.`);
    }
    
    // üîç **GET FILE STATS**: L·∫•y th√¥ng tin file ƒë·ªÉ t√≠nh duration estimate
    const inputStats = await fs.stat(inputPath);
    
    // üÜï **GENERATE OUTPUT FILENAME**: T·∫°o filename cho file output v·ªõi speed indicator V√Ä FORMAT
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 6);
    const originalName = path.parse(fileId).name; // L·∫•y t√™n g·ªëc kh√¥ng c√≥ extension
    const speedSuffix = playbackRate !== 1 ? `_${playbackRate}x` : ''; // üÜï **SPEED SUFFIX**
    const outputFilename = `cut_${originalName}${speedSuffix}_${timestamp}_${random}.${outputFormat}`; // üö® **KEY FIX**: S·ª≠ d·ª•ng outputFormat
    const outputPath = path.resolve(MP3_CONFIG.PATHS.PROCESSED, outputFilename);

    
    // üîß **ENSURE OUTPUT DIR**: ƒê·∫£m b·∫£o th∆∞ m·ª•c output t·ªìn t·∫°i v·ªõi absolute path
    const outputDir = path.resolve(MP3_CONFIG.PATHS.PROCESSED);
    await fs.mkdir(outputDir, { recursive: true });
    
    // üöÄ **CUT AUDIO WITH SPEED, FORMAT & WEBSOCKET**: Th·ª±c hi·ªán cut audio v·ªõi FFmpeg, speed change, format conversion v√† WebSocket progress
    const cutResult = await MP3Utils.cutAudio(inputPath, outputPath, {
      startTime, 
      endTime, 
      fadeIn, 
      fadeOut, 
      playbackRate, // üÜï **PASS SPEED**: Truy·ªÅn playback rate to FFmpeg
      format: outputFormat, // üö® **KEY FIX**: Truy·ªÅn format ƒë√∫ng thay v√¨ c·ª©ng ƒë·ªãnh 'mp3'
      quality, // üö® **KEY FIX**: Truy·ªÅn quality ƒë√∫ng
      isInverted, // üÜï **INVERT MODE**: Pass invert mode to FFmpeg
      sessionId // üÜï **PASS SESSION ID**: Truy·ªÅn sessionId cho WebSocket progress
    });

    
    // üîç **VERIFY OUTPUT FILE**: Ki·ªÉm tra file output ƒë√£ ƒë∆∞·ª£c t·∫°o
    try {
      await fs.access(outputPath);
    } catch (error) {
      console.error('‚ùå [cutAudioByFileId] Output file not created:', {
        outputPath,
        error: error.message
      });
      throw new Error(`Cut operation failed: Output file not created`);
    }
    
    // üîç **GET OUTPUT STATS**: L·∫•y th√¥ng tin file output
    const outputStats = await fs.stat(outputPath);
    
    // üßπ **AUTO CLEANUP**: T·ª± ƒë·ªông x√≥a file sau 24 gi·ªù
    setTimeout(() => {
      fs.unlink(outputPath).catch(() => {
      });
    }, 24 * 60 * 60 * 1000);
    
    // üéØ **RETURN STANDARDIZED RESULT**: Tr·∫£ v·ªÅ k·∫øt qu·∫£ v·ªõi format chu·∫©n
    return {
      input: {
        filename: fileId,
        originalName: originalName,
        path: inputPath,
        size: inputStats.size
      },
      output: {
        filename: outputFilename, // üéØ **KEY FIX**: ƒê·∫£m b·∫£o tr·∫£ v·ªÅ ƒë√∫ng t√™n field v·ªõi extension format ƒë√∫ng
        path: outputPath,
        duration: endTime - startTime,
        size: outputStats.size,
        format: outputFormat, // üÜï **INCLUDE FORMAT**: Include format in response
        quality // üÜï **INCLUDE QUALITY**: Include quality in response
      },
      processing: { 
        startTime, 
        endTime, 
        fadeIn, 
        fadeOut,
        playbackRate, // üÜï **INCLUDE SPEED**: Include playback rate in response
        outputFormat, // üÜï **INCLUDE FORMAT**: Include format in processing info
        quality, // üÜï **INCLUDE QUALITY**: Include quality in processing info
        actualDuration: cutResult.settings?.duration || (endTime - startTime),
        speedApplied: playbackRate !== 1 ? `${playbackRate}x` : 'normal', // üîß **DEBUG**: Confirm speed applied
        formatApplied: `${outputFormat.toUpperCase()}` // üÜï **FORMAT DEBUG**: Confirm format applied
      },
      urls: {
        download: `/api/mp3-cutter/download/${outputFilename}`
      },
      processedAt: new Date().toISOString()
    };
  }

  /**
   * üÜï **CHANGE AUDIO SPEED BY FILE ID**: Ch·ªâ thay ƒë·ªïi t·ªëc ƒë·ªô audio, kh√¥ng c·∫Øt ƒëo·∫°n
   */
  static async changeAudioSpeedByFileId(fileId, speedParams) {
    const { playbackRate = 1, outputFormat = 'mp3', quality = 'medium' } = speedParams;
    
    
    // üîç **FIND INPUT FILE**: T√¨m file ƒë√£ upload theo fileId v·ªõi absolute path
    const inputPath = path.resolve(MP3_CONFIG.PATHS.UPLOADS, fileId);
    
    try {
      // üîç **CHECK FILE EXISTS**: Ki·ªÉm tra file c√≥ t·ªìn t·∫°i
      await fs.access(inputPath);
    } catch (error) {
      console.error('‚ùå [changeAudioSpeedByFileId] Input file not found:', {
        fileId,
        inputPath,
        error: error.message
      });
      throw new Error(`File not found: ${fileId}. Please upload the file again.`);
    }
    
    // üîç **GET FILE STATS**: L·∫•y th√¥ng tin file
    const inputStats = await fs.stat(inputPath);
    
    // üÜï **GENERATE OUTPUT FILENAME**: T·∫°o filename cho file output v·ªõi speed
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 6);
    const originalName = path.parse(fileId).name;
    const speedSuffix = `_${playbackRate}x`;
    const outputFilename = `speed_${originalName}${speedSuffix}_${timestamp}_${random}.${outputFormat}`;
    const outputPath = path.resolve(MP3_CONFIG.PATHS.PROCESSED, outputFilename);

    
    // üîß **ENSURE OUTPUT DIR**: ƒê·∫£m b·∫£o th∆∞ m·ª•c output t·ªìn t·∫°i
    const outputDir = path.resolve(MP3_CONFIG.PATHS.PROCESSED);
    await fs.mkdir(outputDir, { recursive: true });
    

    
    // üöÄ **CHANGE SPEED**: Th·ª±c hi·ªán thay ƒë·ªïi t·ªëc ƒë·ªô v·ªõi FFmpeg
    const speedResult = await MP3Utils.changeAudioSpeed(inputPath, outputPath, {
      playbackRate,
      format: outputFormat,
      quality
    });
    
    // üîç **VERIFY OUTPUT FILE**: Ki·ªÉm tra file output ƒë√£ ƒë∆∞·ª£c t·∫°o
    try {
      await fs.access(outputPath);
    } catch (error) {
      console.error('‚ùå [changeAudioSpeedByFileId] Output file not created:', {
        outputPath,
        error: error.message
      });
      throw new Error(`Speed change failed: Output file not created`);
    }
    
    // üîç **GET OUTPUT STATS**: L·∫•y th√¥ng tin file output
    const outputStats = await fs.stat(outputPath);
    
    // üßπ **AUTO CLEANUP**: T·ª± ƒë·ªông x√≥a file sau 24 gi·ªù
    setTimeout(() => {
      fs.unlink(outputPath).catch(() => {
      });
    }, 24 * 60 * 60 * 1000);
    
    // üéØ **RETURN STANDARDIZED RESULT**: Tr·∫£ v·ªÅ k·∫øt qu·∫£ v·ªõi format chu·∫©n
    return {
      input: {
        filename: fileId,
        originalName: originalName,
        path: inputPath,
        size: inputStats.size
      },
      output: {
        filename: outputFilename,
        path: outputPath,
        size: outputStats.size
      },
      processing: { 
        playbackRate,
        outputFormat,
        quality
      },
      urls: {
        download: `/api/mp3-cutter/download/${outputFilename}`
      },
      processedAt: new Date().toISOString()
    };
  }

  static async generateWaveform(file, audioInfo, waveformParams) {
    const { samples } = waveformParams;
    const waveformResult = await MP3Utils.generateWaveform(file.path, samples);
    
    return {
      file: {
        filename: file.filename,
        originalName: file.originalname,
        duration: audioInfo.duration
      },
      waveform: {
        data: waveformResult.waveform,
        samples: waveformResult.samples,
        duration: audioInfo.duration
      },
      generatedAt: new Date().toISOString()
    };
  }

  /**
   * üîç **GET FILE FOR DOWNLOAD**: Get file for download by filename
   */
  static async getFileForDownload(filename) {
    // üîç **SEARCH IN PROCESSED FOLDER FIRST**: Most downloads are processed files
    const processedPath = path.resolve(MP3_CONFIG.PATHS.PROCESSED, filename);
    
    try {
      await fs.access(processedPath);
      const stats = await fs.stat(processedPath);
      
      return {
        filename,
        path: processedPath,
        size: stats.size,
        mimeType: MP3Utils.getMimeType(filename)
      };
    } catch (error) {
      // File not in processed folder, try uploads folder
    }
    
    // üîç **FALLBACK TO UPLOADS FOLDER**: Check uploads folder
    const uploadsPath = path.resolve(MP3_CONFIG.PATHS.UPLOADS, filename);
    
    try {
      await fs.access(uploadsPath);
      const stats = await fs.stat(uploadsPath);
      
      return {
        filename,
        path: uploadsPath,
        size: stats.size,
        mimeType: MP3Utils.getMimeType(filename)
      };
    } catch (error) {
      throw new Error(`File not found: ${filename}`);
    }
  }

  /**
   * üîç **DEBUG FILES**: Debug file system (development only)
   */
  static async debugFiles() {
    const result = {
      paths: {
        uploads: {
          relative: MP3_CONFIG.PATHS.UPLOADS,
          absolute: path.resolve(MP3_CONFIG.PATHS.UPLOADS)
        },
        processed: {
          relative: MP3_CONFIG.PATHS.PROCESSED,
          absolute: path.resolve(MP3_CONFIG.PATHS.PROCESSED)
        }
      },
      files: {}
    };

    // üîç **CHECK UPLOADS FOLDER**
    try {
      const uploadsPath = path.resolve(MP3_CONFIG.PATHS.UPLOADS);
      const uploadFiles = await fs.readdir(uploadsPath);
      result.files.uploads = uploadFiles.map(file => ({
        name: file,
        fullPath: path.join(uploadsPath, file)
      }));
    } catch (error) {
      result.files.uploads = { error: error.message };
    }

    // üîç **CHECK PROCESSED FOLDER**
    try {
      const processedPath = path.resolve(MP3_CONFIG.PATHS.PROCESSED);
      const processedFiles = await fs.readdir(processedPath);
      result.files.processed = processedFiles.map(file => ({
        name: file,
        fullPath: path.join(processedPath, file)
      }));
    } catch (error) {
      result.files.processed = { error: error.message };
    }

    return result;
  }
}